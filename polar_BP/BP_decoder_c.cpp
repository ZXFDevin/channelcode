#include "mex.h"		//用于matlab进行调用
#include<cassert>
#include<iostream>
#include<cmath>
//#include <time.h>
//#include <windows.h>
using namespace std;
/*****************************第1部分，编写栈的类，用于后续需要生成栈的地方********************************/
template<typename T>class Stack {
	int top;		//栈顶指针  top是int型数据，所以应该是索引，而不是指针
	T *elements;    //动态建立栈
	int maxSize;	//栈的最大容量
public:
	Stack(int = 20);  //若未指定容量大小，初始化为20
	~Stack() { delete[] elements; }
	void Push(const T &data);		//压栈
	T Pop();						//弹出数据，top--
	T GetElem(int i);				//读取数据，top不变
	void MakeEmpty() { top = -1; }		//将栈清空
	bool IsEmpty() const { return top == -1; }		//判断栈空
	bool IsFull() const { return top == maxSize - 1; } //判断栈满
	void PrintStack();				//输出栈内所有数据

};

template<typename T>Stack<T>::Stack(int maxs) {				//栈的生成，空间的分配
	maxSize = maxs;
	top = -1;
	elements = new T[maxSize];		//动态建立栈空间
	assert(elements != 0);			//分配不成功，结束程序
}

template<typename T>void Stack<T>::PrintStack() {			//打印栈中的数据
	for (int index = 0; index <= top; index++) cout << elements[index] << '\t';
	cout << endl;
}

template<typename T>void Stack<T>::Push(const T &data) {		//数据进栈
	assert(!IsFull());		//栈满，不可压入数据，推出操作  assert为断言，里面判断为false，则终止操作
	elements[++top] = data;			//栈顶指针先加1，再将数据压入栈中
}

template<typename T>T Stack<T>::Pop() {					//数据出栈
	assert(!IsEmpty());	//栈空，则退出操作
	return elements[top--];			//先返回栈顶元素，然后top减1.
}

template<typename T>T Stack<T>::GetElem(int i) {					//数据出栈
	assert(i <= top&&i >= 0);	//数据超出有效范围，则退出操作
	return elements[i];
}
/*****************完成栈类的编写1************************/

/****************************************第2部分，数据初始化********************************************/
/*这一部分的主要工作是对数据进行初始化，编写重要的
数据结构和对数据结构的验证与初始化，需要说明的是：
主要是使用函数initialDataStructures()，该函数将在
主程序中使用*/

int const		m = 8;								//层数，将作为译码器的输入参数
int const		N = 256;							//码长，将作为译码器的输入参数,随m的变化而变化，N = 2^m;
double const		max_iter = 80;								//最大迭代次数

double		L_LLR[m+1][N];			// 左信息矩阵
double		R_LLR[m+1][N];			//右信息矩阵 
int			code[N];							//用于记录最后的码字	
int         X_sequence[N];                   //用于记录输入的U序列
double      total_iter;                 //用于记录迭代次数
int      check_pass;                 //通过矩阵校验指示
void initialDataStructures()					//在主程序中要使用这句话来实现数据结构的初始化
{
	for (int lamda = 0; lamda < m+1; lamda++)
	{
		for (int index = 0; index<N; index++)
		{
			L_LLR[lamda][index] = 0;
			R_LLR[lamda][index] = 0;
		}
	}
}
/*****************完成数据初始化2************************/

/****************************************第3部分，底层函数********************************************/

//求最小值
double my_min(double a, double b)
{
	return a <= b ? a : b;
}
//取符号
double my_sign(double a) {
	return a>0 ? 1.0 : -1.0;
}
//取绝对值
double my_abs(double a) {
	return a>0 ? a : -a;
}
//置信传播基础运算单元
double fun_g(double a, double b) {
	double c;
     //double x;
    // x=tanh(a/2)*tanh(b/2);
    //c=log((1+x)/(1-x));//反双曲正切
	//c = 2 * atanh(tanh(a/2)*tanh(b/2));
	c =0.9375 *my_sign(a)*my_sign(b)*my_min(my_abs(a),my_abs(b));
	return c;
}

//说明：Y_received指针，表示接收向量，A_C为frozen bits的下标索引;该函数操作得到的码字直接存储于全局变量code中
void BP_Decoder(double *Y_received, double sigma, double *A_C, int A_C_length)
{
	//初始化
    int		check_code[m+1][N];			//用于计算code*GN
    int     stop_iter=0;
	initialDataStructures();
	//将double型的A_C转换为int型的A_C;
	int *A_C_int = new int[A_C_length];
	for (int A_C_index = 0; A_C_index < A_C_length; A_C_index++)
	{
		A_C_int[A_C_index] = int(A_C[A_C_index]);
	}
	//赋值初始LLR
	for (int index = 0; index < N; index++)
	{
		L_LLR[m][index] = 2 * Y_received[index]/(double(pow(sigma, 2)));
		if (A_C_int[index] == 1)
		{
			R_LLR[0][index] = double(pow(10.0, 100));
		}

	}

	//开始主循环
	for (int iter = 0; iter < max_iter; iter++)
	{
        //计算左信息
		for (int lambda = 1; lambda < m+1; lambda++)
		{ 
			for (int phi = 0; phi < int(pow(2.0,lambda)); phi++)
			{
				int psi = phi/2;
				for (int omega = 0; omega < int(pow(2.0, m - lambda)); omega++)
				{
					if (phi % 2 == 0)
					{
						L_LLR[m-lambda][phi+omega*int(pow(2.0,lambda))] = fun_g(L_LLR[m+1-lambda][psi+2*omega*int(pow(2.0,(lambda-1)))], L_LLR[m+1-lambda][psi+(2*omega+1)*int(pow(2.0,(lambda-1)))]+R_LLR[m-lambda][phi+1+omega *int( pow(2.0,lambda))]);
					}
					else
					{
						L_LLR[m-lambda][phi+omega*int(pow(2.0,lambda))] = L_LLR[m+1-lambda][psi+(2*omega+1)*int(pow(2.0,(lambda-1)))]+fun_g(L_LLR[m+1-lambda][psi+2*omega*int(pow(2.0,(lambda-1)))] , R_LLR[m-lambda][phi-1+omega*int( pow(2.0,lambda))]);
					} 
				}
			}
		}

        //计算右信息
		for (int lambda = m; lambda >0; lambda--)
		{
			for (int phi = 0; phi < int(pow(2.0, lambda)); phi++)
			{
				int psi = phi/2;
					if (phi % 2 != 0)
					{
						for (int omega = 0; omega < int(pow(2.0, m - lambda)); omega++)
						{
							R_LLR[m + 1-lambda][psi+2*omega*int(pow(2.0,(lambda-1)))] = fun_g(L_LLR[m+1-lambda][psi+(2*omega+1)*int(pow(2.0,(lambda-1)))]+R_LLR[m-lambda][phi+omega*int( pow(2.0,lambda))], R_LLR[m-lambda][phi-1+omega*int( pow(2.0,lambda))]);
							R_LLR[m + 1-lambda][psi+(2*omega+1)*int(pow(2.0,(lambda-1)))] = R_LLR[m-lambda][phi+omega*int( pow(2.0,lambda))] + fun_g(L_LLR[m+1-lambda][psi+2*omega*int(pow(2.0,(lambda-1)))], R_LLR[m-lambda][phi-1+omega *int( pow(2.0,lambda))]);
						}
					}
			}

			}
        
        //获得判决信息
        for (int index = 0; index<N; index++)
		{
			if (A_C_int[index] == 1)
			{
				code[index] = 0;
              check_code[0][index]=0;			
			}
			else
			{
				if ((L_LLR[0][index] + R_LLR[0][index]) < 0)
				{
					code[index] = 1;
                     check_code[0][index]=1;
				}
				else
				{
					code[index] = 0;
                     check_code[0][index]=0;
				}
			}
        //右端编码信息
			if ((R_LLR[m][index]+L_LLR[m][index]) < 0)
			{
				X_sequence[index] = 1;
			}
			else
			{
				X_sequence [index]= 0;
			}
		}
        
        //获得用于校验的编码信息
        for (int lambda = m; lambda >0; lambda--)
		{
			for (int phi = 0; phi < int(pow(2.0, lambda)); phi++)
			{
				int psi = phi/2;
					if (phi % 2 != 0)
					{
						for (int omega = 0; omega < int(pow(2.0, m - lambda)); omega++)
						{
							check_code[m + 1-lambda][psi+2*omega*int(pow(2.0,(lambda-1)))] = (check_code[m-lambda][phi+omega*int( pow(2.0,lambda))]+check_code[m-lambda][phi-1+omega*int( pow(2.0,lambda))])%2;
							check_code[m + 1-lambda][psi+(2*omega+1)*int(pow(2.0,(lambda-1)))] = check_code[m-lambda][phi+omega*int( pow(2.0,lambda))];
						}
					}
			}

			}
        //迭代停止判断
			stop_iter=0;
		for (int index = 0; index<N; index++)
		{
			if (check_code[m][index]!=X_sequence[index])
			{stop_iter=stop_iter+1;}
		}
			if (stop_iter==0)
		{
			total_iter = iter+1;
            check_pass=1;
			break;}
            else
            {total_iter = max_iter;
            check_pass=0;}
		
        
        
    }
		//开始释放内存
		delete[] A_C_int;
}


//调试
/*void main()
{
	double sigma = 0.794328234724282;
	double Y_received[512] = {-0.838531506738184, -0.183266744924836, 1.16025748403511, 0.912980937112294, -0.978337363695464, -1.92428697729881, -1.34239638896729, 0.481220355117733, -0.138222823280138, -0.497523192027152, 0.936029421342802, 0.788067740235614, 0.136509170969906, -0.160257330480575, -1.44456042165035, -1.69608396617729, -1.15796673638059, 1.12596865676989, 2.03541294657136, 0.334242336133564, -0.225034966478173, 2.22545582172586, 0.455139430213862, -0.484328995570855, -0.0152287562326439, -0.711855602376027, -0.845391630343493, -0.251485093166637, 1.39834597029085, 0.0458961543035668, 0.747738321357257, -1.42191972617157, -0.832633290421975, -1.25038854261801, 0.0432020115221217, -0.444962589274930, 0.240414322967749, -2.66470547578425, 0.918864076830573, -1.25815841682018, -1.33147458192547, -0.765029271654609, 0.401116559261174, -0.422512403909868, -1.89882261467712, -0.00276988525936350, 0.132306285527014, 0.549183922212055, 1.55544445145292, 1.58968846067092, -0.472608276956192, -2.27899661017116, -1.31624534755928, -0.357981077441792, 0.662777194659002, 1.56469620454227, -1.08204148698067, 0.226043655440455, -1.25649230707233, 0.328739980667222, 0.951971069742745, -1.16855820562954, -1.54575375985074, -0.382366494119940, -0.660707484298812, -0.762654308989196, -1.57673986150496, -1.11186225287824, 1.73673197654045, 1.82243407157488, -2.34674475330899, -1.74503998005957, 1.59917745870447, 2.65702163966917, 0.0595628259510113, -0.674539812127444, -0.856716194306673, -0.284890930234335, 1.08265704772688, 0.472049185411224, 1.92527077797324, 0.293822595357909, 2.41176201869893, -0.180754987468541, 0.990210109133124, -0.464324391972914, 0.926420405321776, -2.87608479739393, 1.34010337359049, 1.76383876966057, -0.750131577291579, 2.30222324054062, 0.599762914541055, 0.0622850819382702, 0.422856297490500, -0.799908702283910, 1.70161458907856, -1.43567713355721, 0.378509865420819, 1.16410496806965, 1.11606170811371, -1.05587345480487, -0.877495880111539, 0.552991302661357, 0.0274507664185634, -1.32487018681880, 0.682788091032341, -1.47910381854902, -0.700947311582571, -0.687951066965441, -0.0180441057537681, 0.227245051349129, 0.766146678169418, 0.0789143879138431, -1.27282787408211, 1.33826132316408, -0.287596503218454, 0.497729835784370, -1.26821909476052, -0.764696255242122, -1.17877577463474, 0.0367426364886136, -0.852889555527021, -2.40471387401256, 0.628107601155864, 0.792787510791869, 1.00550932148885, 0.609107475081548, 1.47158747618453, 1.24090367580615, 1.57499406195842, -0.404027312192656, 0.342382552278359, -1.98716930276450, -1.50550136180011, -1.51888653583140, -0.643501559574633, 0.412350195642661, 2.39144780876215, 2.44435323756367, 0.655552077896926, 1.78786315558909, 2.57449641076142, 1.21789543963766, -2.65655719850775, -0.516412768503342, -1.92880623188155, 1.56300525536215, 2.31671911542266, -0.757140431390436, -0.132674621153709, -1.68535481953687, 0.576313956562349, -1.66150791191435, -1.03796563705071, 2.39411524677053, -0.795554035062140, 0.971144742138591, 0.542340990128864, 1.51600826080793, -1.81385671426024, -0.705674248667079, -2.26740474302645, -2.75396717762552, 2.18385294941477, -0.898207685632354, -0.772390357871249, 0.621556736320677, -0.965372190852422, -0.351057994556422, 0.644088093602115, -1.13357100984793, -0.656844039166491, 2.06521169323091, 1.55035081116325, -0.656566905048628, -1.51152139656346, -0.978011556615074, -0.739646128969652, -0.480524937575286, -1.99807434535467, 1.78309049016140, 0.701490799535638, -2.38974494851351, -1.07175466853963, 1.25307974968662, -0.851012145036695, -1.93778535705552, -1.66643197074491, 0.543397823796347, 1.92750993232916, 0.814255183301710, -1.18931599136928, -2.49997923068901, 0.631536888448527, -0.804398987999097, 1.83891417956891, -0.399050108013605, -1.19629219298035, -0.615920690878503, 2.43116525297151, -2.41569549578613, -0.446991121607980, 0.671634962210262, -1.42675030799428, 0.768263032026348, 2.26383050504594, -1.06937450391285, -0.360172383376191, 0.313864211575711, -0.448355970687434, -1.37955352864660, -0.0121098844467614, -1.80846451680143, 0.497492850361355, -0.303664199101956, -1.10520159795156, 0.851864723851879, 1.47743331871422, -0.599654357423816, 2.13541250462757, -1.27349299740478, 0.455508862092184, -0.143433147171528, -0.799063220844089, -0.793123759911553, 0.700574002895094, 0.125351421695266, 2.73032123242556, -0.548274561873148, -1.39705116443047, 1.32525676326038, 1.29014432209319, 2.19587593130252, -1.14641279427329, 1.54304120003486, 0.165489556174736, -0.165710336269273, -1.33949905350300, 1.39035938414654, -1.93725240898895, -1.02278804095892, 0.879081292106507, 0.790486574267830, -3.29198490684390, 0.996670273146495, -3.23059155233158, -0.191981871709153, 1.43609010925518, -0.616074098217731, -0.0270359039702056, 0.00343663668414007, -0.506621089698736, 1.21876378851735, -1.21343387543072, -2.52802264525011, -0.559754307673197, -1.36180725313697, 1.17810071769672, 0.149001557951350, -1.39486545889500, 2.95778030904034, 0.780135464189069, -0.181774210624068, 0.0244571894403565, 1.22228861909407, -1.15844297125304, -0.608499917904595, -1.05438637609774, 0.786804330824426, -0.960454206878935, -0.188430647096940, -1.31322484339234, -1.61437622895302, -1.24582175478416, -1.25760621579683, 1.00061205070931, 0.202107843992213, 1.31369201350579, -0.602074422988215, -0.715183331105951, 2.15257698989155, -1.78497881632635, -1.81306107768066, 1.67405074276856, -0.647842019169203, 1.21183442406272, 2.48419222295113, -0.844558319215401, 1.48983919086938, -2.15982616189729, 0.264129713383444, -0.459277165206908, -0.962632894771528, -1.40130782101598, -0.0789727852445669, 1.09162368024339, -0.409946065480536, -0.288660722984884, -1.05010292851201, -1.08164555757558, -0.861294605049767, -1.10326054873302, -0.603742430405245, -0.166327958941176, 1.88606770859422, 0.977201266500103, -1.07197329196323, 0.189669346845966, -0.489359516787285, -1.63598815552067, -0.832801805795210, 0.560527499323020, 0.0314162233419710, 0.119239737774966, -2.06530654954591, -0.844346796879240, -0.666152806724029, 0.110337593090956, -0.191376325470356, 2.16439946912415, -0.858509565897703, 0.234253948025969, -0.572774038336801, 2.09226741712405, -0.311273217111403, -0.219557919132983, 2.16716236776518, 0.624640534847619, 0.186864685168189, 0.0576799557743145, -0.936903024686440, 0.151931919613601, -0.694092255128415, -0.668312055885753, 0.125651597180110, 0.503611612998768, 0.361554892362982, -0.553858163520027, -0.730025464365222, -1.81160770027559, -0.450326868261798, 1.85028523988784, -0.261850119881686, -2.83728053716026, 1.54026337506497, 1.11309991746573, 0.833705503908943, 0.157971967796393, 0.507459301279730, -0.501095577683137, 1.08451211290848, 0.0209067508045476, -0.897560257597277, -1.49849308161194, -1.46129858719287, -0.664001830383957, 1.07716615531910, 1.06213425225523, 0.501345550402826, 1.01256997758331, 1.69525150692639, 2.54478080347591, 1.72738741838709, 1.17658155736090, -0.769567782963521, 1.60050234924832, -1.70352053308729, -0.877473686348795, 1.30193310830785, 1.70616101577794, -0.125832803840477, -1.65345856453333, 1.36006904774957, -1.23537719268157, -0.403422254481199, 2.09144491585360, 0.443685238641990, -2.19332265247185, -1.12159146101951, 2.42764639704003, 0.0199209611206714, 0.874759866623173, -0.535191279021135, -2.30665210679146, 0.548641699902819, 1.64983995934636, -0.451914667945919, -0.854773472599306, 0.760816907316560, 1.95426375168649, 0.968076566233639, 0.681824154643457, -3.08298351611068, -0.724310090696111, -1.92206232439560, 0.855587396787579, -2.25797524716648, 1.59755693660853, 1.53074684167732, -1.10372829971432, 1.41541925696782, -0.358783075626848, 0.562368529494033, 0.169515590102354, -0.751852784122474, -0.178789435839857, -0.496875938395659, -0.619927900717879, -2.45868565879946, -0.997269843723629, 0.602794158458814, 0.869430452682652, -0.278904481804778, -0.768270892561474, -2.49019063933885, 1.30934405517833, -1.45850265050048, 1.91176949149888, 1.48990138972295, -0.350448478710936, -1.11521638242546, -0.604683331637110, 2.54820307976032, -1.13722403818936, 0.942292637258034, 1.02287397346035, -1.44751721323775, 0.221513680872094, -1.81298783697315, 0.970551129380280, -2.00804658977693, -1.02539069207403, -0.628421843202803, -0.995944262167231, -0.727440928746207, 0.237025551408120, -1.60733421574617, -0.0479349944851852, 1.81774752421299, 0.953707368726409, -0.476110334356388, 0.840474650440039, 0.746803158903493, 0.935067814288219, -0.819144662423156, -0.228608568468922, 0.158543129918428, -0.804303195874458, -1.56947886032484, 0.0820353984917628, -1.43252441961464, -0.988910994839858, 0.978804836811849, 1.10492555914263, -0.0241564536683601, -0.584438023912446, -2.32249135323471, -0.00561422812231149, 0.693877967269172, 0.216600687986766, -0.753132089701459, -1.90614757989553, -1.47029529073678, 1.90146909449938, -2.41227003338396, -0.768258019864290, 1.18213835251389, -1.60172158491103, 1.21054091090310, 1.32145984926597, 1.01332616753362, 0.805528289175611, 1.56932795787549, -1.77985978331883, -0.839141930176318, -1.47784220961147, 1.69007940771095, 0.226308169283724, -1.46862200240457, -1.42626079571440, -1.33462474115050, -0.138025552227367, -1.14323442283066, 1.47756159553819, -0.726845367922314, 0.800432630667604, -0.844737121979851, 0.0295589863092901, 0.451558848747641, 0.786322476209802, -0.134154329819490, -1.28279297493325, 0.467217380185581, 1.45519720763382, 1.22332927486867, 1.44999429707145, 2.00829955939186, -0.763276347788668, -2.07855216580330, -0.782603379999978, -0.950380733052388, -0.150652513724909, -2.03325751051736, -1.09702390732140, -1.48328933855499, 2.38431181841008, -0.824951556901809, -0.854759581819269, 2.19249196242752, -0.0863187350643258, 0.513521379375934};

	double A_C[512] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	int A_C_length = 512;

	clock_t start_time = clock();


	for (int i = 0; i <1000; i++)
	{
		BP_Decoder(Y_received, sigma, A_C, A_C_length);
	}
	clock_t end_time = clock();
	cout << "程序段运行时间：" << static_cast<double> (end_time - start_time) / CLOCKS_PER_SEC * 1000 << "ms" << endl;

	cin.get();

	int a = 1;

}*/



/****************************************第6部分，matlab调用接口的编写********************************************/

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
//输入输出检错
if (nlhs != 4)
{
mexErrMsgTxt("four output required!");                   //注意，此时要求的输出的数据4个
}
if (nrhs != 4)
{
mexErrMsgTxt("four input required!");
}
if (mxGetM(prhs[0]) != 1)//说明Y_received的M不为1,即行数不为1，报错
{
mexErrMsgTxt("Y_received must be a row vector!");
}
if (mxGetM(prhs[1])*mxGetN(prhs[1]) != 1)//说明sigma不为数值，报错
{
mexErrMsgTxt("sigma must be a number,not a vector!");
}
if (mxGetM(prhs[1])*mxGetN(prhs[3]) != 1)//说明A_C_length不为数值，报错
{
mexErrMsgTxt("A_C_length must be a number,not a vector!");
}

double *Y_received = mxGetPr(prhs[0]);
double *sigma = mxGetPr(prhs[1]);
double *A_C = mxGetPr(prhs[2]);
double *A_C_length = mxGetPr(prhs[3]);


//开始进行译码操作
	BP_Decoder(Y_received, *sigma, A_C, int(*A_C_length));

//将全局变量code的值赋值给函数输出
plhs[0] = mxCreateDoubleMatrix(N, 1, mxREAL);//设置输出的维度
plhs[1] = mxCreateDoubleMatrix(N, 1, mxREAL);//设置输出的维度
plhs[2] = mxCreateDoubleMatrix(1, 1, mxREAL);//设置输出的维度
plhs[3] = mxCreateDoubleMatrix(1, 1, mxREAL);//设置输出的维度

double *result_code = mxGetPr(plhs[0]);                     //返回每条路径上的码字
double *result_X_sequence = mxGetPr(plhs[1]);               //返回每条路径上U序列
double *result_total_iter = mxGetPr(plhs[2]);          //迭代次数
double *result_check_pass = mxGetPr(plhs[3]);          //是否通过校验

for (int phi = 0; phi<N; phi++)
{
*(result_code + phi) = code[phi];                     //完成code的输出
*(result_X_sequence + phi) = X_sequence[phi];         //完成X_sequence的输出
}

* result_total_iter =double( total_iter);         //完成result_total_iter的输出
* result_check_pass =double( check_pass);         //完成result_total_iter的输出
}
/*****************完成matlab调用接口的编写4************************/


